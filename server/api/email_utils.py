from typing import Iterable

from django.conf import settings
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.utils.html import strip_tags
from django.templatetags.static import static


# Template paths under api/templates/emails
BOOKING_CONFIRMED_TEMPLATE = "emails/booking_confirmed.html"
BOOKING_CANCELLED_TEMPLATE = "emails/booking_cancelled.html"


def get_bloom_logo_url() -> str:
    """
    URL for the Bloom logo used in emails.

    Uses BLOOM_LOGO_URL from settings if present, otherwise falls
    back to the static path (useful for local/dev).
    """
    logo_url = getattr(settings, "BLOOM_LOGO_URL", None)
    if logo_url:
        return logo_url

    # Fallback â€“ relative static path; fine for local / console email previews
    return static("images/bloom_logo.png")


def send_simple_email(
    subject: str,
    message: str | None,
    recipients: Iterable[str],
    *,
    html_template: str | None = None,
    context: dict | None = None,
    from_email: str | None = None,
    fail_silently: bool = False,
) -> int:
    """
    Wrapper for Django's send_mail using EMAIL_HOST_USER.

    - If `html_template` is provided, it renders that template with `context`
      and sends it as HTML email.
    - If `message` is None, it will be generated by stripping HTML tags from
      the rendered HTML so a plain-text body is still sent.
    - Existing plain-text usage still works: pass `subject`, `message`,
      and `recipients` without `html_template`.
    """
    if from_email is None:
        from_email = settings.EMAIL_HOST_USER

    html_message = None

    if html_template is not None:
        context = context or {}
        html_message = render_to_string(html_template, context)
        # Derive plain text from HTML if not explicitly provided
        if message is None:
            message = strip_tags(html_message)

    # Django requires a non-empty string for `message`
    if message is None:
        message = ""

    return send_mail(
        subject=subject,
        message=message,
        from_email=from_email,
        recipient_list=list(recipients),
        fail_silently=fail_silently,
        html_message=html_message,
    )


def send_booking_confirmed_email(
    recipients: Iterable[str],
    *,
    context: dict,
    subject: str = "Booking confirmed!",
    fail_silently: bool = False,
) -> int:
    """
    Convenience wrapper for the booking confirmed HTML template.
    Expects `context` to match the variables used in
    emails/booking_confirmed.html.
    """
    ctx = dict(context or {})
    ctx.setdefault("bloom_logo_url", get_bloom_logo_url())

    return send_simple_email(
        subject=subject,
        message=None,
        recipients=recipients,
        html_template=BOOKING_CONFIRMED_TEMPLATE,
        context=ctx,
        fail_silently=fail_silently,
    )


def send_booking_cancelled_email(
    recipients: Iterable[str],
    *,
    context: dict,
    subject: str = "Booking cancelled!",
    fail_silently: bool = False,
) -> int:
    """
    Convenience wrapper for the booking cancelled HTML template.
    Expects `context` to match the variables used in
    emails/booking_cancelled.html.
    """
    ctx = dict(context or {})
    ctx.setdefault("bloom_logo_url", get_bloom_logo_url())

    return send_simple_email(
        subject=subject,
        message=None,
        recipients=recipients,
        html_template=BOOKING_CANCELLED_TEMPLATE,
        context=ctx,
        fail_silently=fail_silently,
    )
