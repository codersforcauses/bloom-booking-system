from typing import Iterable

from django.conf import settings
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.utils.html import strip_tags
from django.templatetags.static import static

from smtplib import SMTPAuthenticationError, SMTPResponseException

import logging

logger = logging.getLogger(__name__)


# Template paths under api/templates/emails
BOOKING_CONFIRMED_TEMPLATE = "emails/booking_confirmed.html"
BOOKING_CANCELLED_TEMPLATE = "emails/booking_cancelled.html"

"""
Email utilities for booking notifications.

Usage:
- Call `send_booking_confirmed_email` or `send_booking_cancelled_email`
- Pass booking-specific data via the `context` dictionary
- Shared layout and branding (e.g. Bloom logo) are injected automatically

Expected context structure:

Booking confirmed email (`send_booking_confirmed_email`):
context = {
    "room_name": str,          # required
    "start_datetime": datetime,         # required
    "end_datetime": datetime,           # required
    "visitor_name": str,       # required
    "location_name": str,      # required
    "manage_url": str | None,  # optional
}

Booking cancelled email (`send_booking_cancelled_email`):
context = {
    "room_name": str,          # required
    "start_datetime": datetime,         # required
    "end_datetime": datetime,           # required
    "book_room_url": str | None,  # optional
}

Shared variables (injected automatically):
- bloom_logo_url: str

Templates:
- emails/base_booking_email.html (shared layout)
- emails/booking_confirmed.html
- emails/booking_cancelled.html
"""


def get_bloom_logo_url() -> str:
    """
    URL for the Bloom logo used in emails.

    Uses BLOOM_LOGO_URL from settings if present, otherwise falls
    back to the static path (useful for local/dev).
    """
    logo_url = getattr(settings, "BLOOM_LOGO_URL", None)
    if logo_url:
        return logo_url

    # Fallback â€“ relative static path; fine for local / console email previews
    return static("images/bloom_logo.png")


def requires_email_exists(func):
    def wrapper(*args, **kwargs):
        if not settings.EMAIL_HOST_USER:
            logger.warning("EMAIL_HOST_USER is not set. Emails will not be sent.")
            return 0
        return func(*args, **kwargs)
    return wrapper


@requires_email_exists
def send_simple_email(
    subject: str,
    message: str | None,
    recipients: Iterable[str],
    *,
    html_template: str | None = None,
    context: dict | None = None,
    from_email: str | None = None,
    fail_silently: bool = False,
) -> int:
    """
    Wrapper for Django's send_mail using EMAIL_HOST_USER.

    - If `html_template` is provided, it renders that template with `context`
      and sends it as HTML email.
    - If `message` is None, it will be generated by stripping HTML tags from
      the rendered HTML so a plain-text body is still sent.
    - Existing plain-text usage still works: pass `subject`, `message`,
      and `recipients` without `html_template`.
    """
    if from_email is None:
        from_email = settings.EMAIL_HOST_USER

    html_message = None

    if html_template is not None:
        context = context or {}
        html_message = render_to_string(html_template, context)
        # Derive plain text from HTML if not explicitly provided
        if message is None:
            message = strip_tags(html_message)

    # Django requires a non-empty string for `message`
    if message is None:
        message = ""

    # Attempts to send email. If authentication fails with bad credentials, log an error but keep the app running.
    try:
        return send_mail(
            subject=subject,
            message=message,
            from_email=from_email,
            recipient_list=list(recipients),
            fail_silently=fail_silently,
            html_message=html_message,
        )
    except SMTPAuthenticationError:
        logger.error(
            "Failed to send email: SMTP authentication error. from_email=%r",
            from_email,
        )
        return 0
    except SMTPResponseException as e:
        if e.smtp_code == 530:
            logger.error("Failed to send email: SMTP authentication required.")
            return 0
        raise


def send_booking_confirmed_email(
    recipients: Iterable[str],
    *,
    context: dict,
    subject: str = "Booking confirmed!",
    fail_silently: bool = False,
) -> int:
    """
    Convenience wrapper for the booking confirmed HTML template.
    Expects `context` to match the variables used in
    emails/booking_confirmed.html.
    """
    ctx = dict(context or {})
    ctx.setdefault("bloom_logo_url", get_bloom_logo_url())

    return send_simple_email(
        subject=subject,
        message=None,
        recipients=recipients,
        html_template=BOOKING_CONFIRMED_TEMPLATE,
        context=ctx,
        fail_silently=fail_silently,
    )


def send_booking_cancelled_email(
    recipients: Iterable[str],
    *,
    context: dict,
    subject: str = "Booking cancelled!",
    fail_silently: bool = False,
) -> int:
    """
    Convenience wrapper for the booking cancelled HTML template.
    Expects `context` to match the variables used in
    emails/booking_cancelled.html.
    """
    ctx = dict(context or {})
    ctx.setdefault("bloom_logo_url", get_bloom_logo_url())

    return send_simple_email(
        subject=subject,
        message=None,
        recipients=recipients,
        html_template=BOOKING_CANCELLED_TEMPLATE,
        context=ctx,
        fail_silently=fail_silently,
    )
